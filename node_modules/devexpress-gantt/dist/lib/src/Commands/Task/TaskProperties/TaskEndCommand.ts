import { TaskEndHistoryItem } from "../../../Model/History/HistoryItems/Task/Properties/TaskEndHistoryItem";
import { ValidationError } from "../../../Model/Validation/ValidationError";
import { TaskPropertyCommandValidation } from "./TaskPropertyCommandValidation";

export class TaskEndCommand extends TaskPropertyCommandValidation {
    public execute(id: string, value: Date): boolean {
        const success = this.modelManipulator.dispatcher.raiseTaskEndUpdating(this.getTask(id), value, (newStart) => { value = newStart; });
        return success && super.execute(id, value);
    }
    protected executeInternal(id: string, value: Date): boolean {
        return super.executeInternal(id, value);
    }
    protected executeCore(id: string, value: Date): boolean {
        const oldEnd = this.control.viewModel.tasks.getItemById(id).end;
        if(oldEnd.getTime() === value.getTime())
            return false;
        this.control.history.beginTransaction();
        this.history.addAndRedo(new TaskEndHistoryItem(this.modelManipulator, id, value));
        if(this.control.isValidateDependenciesRequired())
            this.control.validationController.moveEndDependTasks(id, oldEnd);
        this.validationController.updateParentsIfRequired(id);
        this.control.history.endTransaction();

        const maxEndTask = this.control.viewModel.tasks.items.reduce((prev, curr) => {
            if(!curr.isValid())
                return prev;
            return prev.end.getTime() > curr.end.getTime() ? prev : curr;
        });
        if(maxEndTask.end > this.control.dataRange.end) {
            this.control.dataRange.end = maxEndTask.end;
            this.control.resetAndUpdate();
        }
        return true;
    }
    protected validate(id: string, value: Date): ValidationError[] {
        return this.control.validationController.checkEndDependencies(id, value);
    }
}
