import { TaskMoveHistoryItem } from "../../../Model/History/HistoryItems/Task/Properties/TaskMoveHistoryItem";
import { ValidationError } from "../../../Model/Validation/ValidationError";
import { DateRange } from "../../../Model/WorkingTime/DateRange";
import { TaskPropertyCommandValidation } from "./TaskPropertyCommandValidation";


export class TaskMoveCommand extends TaskPropertyCommandValidation {
    public execute(id: string, start: Date, end: Date): boolean {
        const success = this.modelManipulator.dispatcher.raiseTaskStartAndEndUpdating(
            this.getTask(id),
            start,
            end,
            (newStart, newEnd) => {
                start = newStart;
                end = newEnd;
            });
        return success && super.execute(id, start, end);
    }
    protected executeInternal(id: string, start: Date, end: Date): boolean {
        return super.executeInternal(id, start, end);
    }
    protected executeCore(id: string, start: Date, end: Date): boolean {
        const task = this.control.viewModel.tasks.getItemById(id);
        const oldDateRange = new DateRange(new Date(task.start.getTime()), new Date(task.end.getTime()));
        this.control.history.beginTransaction();
        this.history.addAndRedo(new TaskMoveHistoryItem(this.modelManipulator, id, new DateRange(start, end)));
        this.validationController.correctParentsOnChildMoving(id, start.getTime() - oldDateRange.start.getTime());
        this.validationController.updateParentsIfRequired(id);
        if(this.control.isValidateDependenciesRequired()) {
            this.control.validationController.moveStartDependTasks(id, oldDateRange.start);
            this.control.validationController.moveEndDependTasks(id, oldDateRange.end);
        }
        this.control.history.endTransaction();

        const maxEndTask = this.control.viewModel.tasks.items.reduce((prev, curr) => {
            if(!curr.isValid())
                return prev;
            return prev.end.getTime() > curr.end.getTime() ? prev : curr;
        });
        if(maxEndTask.end > this.control.dataRange.end) {
            this.control.dataRange.end = maxEndTask.end;
            this.control.resetAndUpdate();
        }
        const minStartTask = this.control.viewModel.tasks.items.reduce((prev, curr) => {
            if(!curr.isValid())
                return prev;
            if(!prev.isValid())
                return curr;
            return prev.start.getTime() < curr.start.getTime() ? prev : curr;
        });
        if(minStartTask.start < this.control.dataRange.start) {
            this.control.dataRange.start = minStartTask.start;
            this.control.resetAndUpdate();
        }
        return true;
    }
    protected validate(id: string, start: Date, end: Date): ValidationError[] {
        const startErrors = this.control.validationController.checkStartDependencies(id, start);
        const endErrors = this.control.validationController.checkEndDependencies(id, end);
        return [...startErrors, ...endErrors];
    }
}
