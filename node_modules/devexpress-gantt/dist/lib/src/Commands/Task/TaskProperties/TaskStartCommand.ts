import { TaskStartHistoryItem } from "../../../Model/History/HistoryItems/Task/Properties/TaskStartHistoryItem";
import { ValidationError } from "../../../Model/Validation/ValidationError";
import { TaskPropertyCommandValidation } from "./TaskPropertyCommandValidation";

export class TaskStartCommand extends TaskPropertyCommandValidation {
    public execute(id: string, value: Date): boolean {
        const success = this.modelManipulator.dispatcher.raiseTaskStartUpdating(this.getTask(id), value, (newStart) => { value = newStart; });
        return success && super.execute(id, value);
    }
    protected executeInternal(id: string, value: Date): boolean {
        return super.executeInternal(id, value);
    }
    protected executeCore(id: string, value: Date): boolean {
        const oldStart = this.control.viewModel.tasks.getItemById(id).start;
        if(oldStart.getTime() === value.getTime())
            return false;
        this.control.history.beginTransaction();
        this.history.addAndRedo(new TaskStartHistoryItem(this.modelManipulator, id, value));
        if(this.control.isValidateDependenciesRequired())
            this.control.validationController.moveStartDependTasks(id, oldStart);
        this.validationController.updateParentsIfRequired(id);
        this.control.history.endTransaction();

        const minStartTask = this.control.viewModel.tasks.items.reduce((prev, curr) => {
            if(!curr.isValid())
                return prev;
            if(!prev.isValid())
                return curr;
            return prev.start.getTime() < curr.start.getTime() ? prev : curr;
        });
        if(minStartTask.start < this.control.dataRange.start) {
            this.control.dataRange.start = minStartTask.start;
            this.control.resetAndUpdate();
        }
        return true;
    }
    protected validate(id: string, value: Date): ValidationError[] {
        return this.control.validationController.checkStartDependencies(id, value);
    }
}
