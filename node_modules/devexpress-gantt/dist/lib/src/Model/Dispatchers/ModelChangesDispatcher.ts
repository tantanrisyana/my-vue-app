import { ResourcesDialogParameters } from "../../Dialogs/DialogParameters/ResourcesDialogParameters";
import { TaskEditParameters } from "../../Dialogs/DialogParameters/TaskEditParameters";
import { ResourceAssignment } from "../Entities/ResourceAssignment";
import { Task } from "../Entities/Task";
import { DependencyInsertingArguments } from "../Events/Dependency/DependencyInsertingArguments";
import { DependencyRemovingArguments } from "../Events/Dependency/DependencyRemovingArguments";
import { ResourceManagerDialogShowingArguments } from "../Events/Dialogs/ResourceManagerDialogShowingArguments";
import { TaskEditDialogShowingArguments } from "../Events/Dialogs/TaskEditDialogShowingArguments";
import { ResourceInsertingArguments } from "../Events/Resource/ResourceInsertingArguments";
import { ResourceRemovingArguments } from "../Events/Resource/ResourceRemovingArguments";
import { ResourceAssigningArguments } from "../Events/ResourceAssignment/ResourceAssigningArguments";
import { ResourceUnassigningArguments } from "../Events/ResourceAssignment/ResourceUnassigningArguments";
import { TaskInsertingArguments } from "../Events/Task/TaskInsertingArguments";
import { TaskRemovingArguments } from "../Events/Task/TaskRemovingArguments";
import { TaskUpdatingArguments } from "../Events/Task/TaskUpdatingArguments";
import { EventDispatcher } from "./EventDispatcher";

export class ModelChangesDispatcher {
    onModelChanged: EventDispatcher = new EventDispatcher();
    private isLocked: boolean = false;

    notifyTaskCreating(args: TaskInsertingArguments): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyTaskCreating", args);
    }

    notifyTaskCreated(task: any, callback: (id: any) => void, errorCallback: () => void): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyTaskCreated", task, callback, errorCallback);
    }
    notifyTaskRemoving(args: TaskRemovingArguments): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyTaskRemoving", args);
    }
    notifyTaskRemoved(taskID: any, errorCallback: () => void, task: any): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyTaskRemoved", taskID, errorCallback, task);
    }
    notifyTaskUpdating(args: TaskUpdatingArguments): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyTaskUpdating", args);
    }
    notifyTaskMoving(args: TaskUpdatingArguments): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyTaskMoving", args);
    }
    notifyTaskEditDialogShowing(args: TaskEditDialogShowingArguments): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyTaskEditDialogShowing", args);
    }
    notifyResourceManagerDialogShowing(args: ResourceManagerDialogShowingArguments): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyResourceManagerDialogShowing", args);
    }
    notifyTaskTitleChanged(taskID: any, newValue: string, errorCallback: () => void): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyTaskTitleChanged", taskID, newValue, errorCallback);
    }
    notifyTaskDescriptionChanged(taskID: any, newValue: string, errorCallback: () => void): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyTaskDescriptionChanged", taskID, newValue, errorCallback);
    }
    notifyTaskStartChanged(taskID: any, newValue: Date, errorCallback: () => void): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyTaskStartChanged", taskID, newValue, errorCallback);
    }
    notifyTaskEndChanged(taskID: any, newValue: Date, errorCallback: () => void): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyTaskEndChanged", taskID, newValue, errorCallback);
    }
    notifyTaskProgressChanged(taskID: any, newValue: number, errorCallback: () => void): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyTaskProgressChanged", taskID, newValue, errorCallback);
    }
    notifyTaskColorChanged(taskID: any, newValue: string, errorCallback: () => void): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyTaskColorChanged", taskID, newValue, errorCallback);
    }
    notifyParentTaskUpdated(task: Task, errorCallback: () => void): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyParentTaskUpdated", task, errorCallback);
    }
    notifyDependencyInserting(args: DependencyInsertingArguments): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyDependencyInserting", args);
    }
    notifyDependencyInserted(dependency: any, callback: (id: any) => void, errorCallback: () => void): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyDependencyInserted", dependency, callback, errorCallback);
    }
    notifyDependencyRemoving(args: DependencyRemovingArguments): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyDependencyRemoving", args);
    }
    notifyDependencyRemoved(dependencyID: any, errorCallback: () => void, dependency: any): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyDependencyRemoved", dependencyID, errorCallback, dependency);
    }
    notifyResourceCreating(args: ResourceInsertingArguments): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyResourceCreating", args);
    }
    notifyResourceCreated(resource: any, callback: (id: any) => void, errorCallback: () => void): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyResourceCreated", resource, callback, errorCallback);
    }
    notifyResourceRemoving(args: ResourceRemovingArguments): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyResourceRemoving", args);
    }
    notifyResourceRemoved(resourceID: any, errorCallback: () => void, resource: any): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyResourceRemoved", resourceID, errorCallback, resource);
    }
    notifyResourceColorChanged(resourceID: any, newValue: string, errorCallback: () => void): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyResourceColorChanged", resourceID, newValue, errorCallback);
    }
    notifyResourceAssigning(args: ResourceAssigningArguments): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyResourceAssigning", args);
    }
    notifyResourceAssigned(assignment: any, callback: (id: any) => void, errorCallback: () => void): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyResourceAssigned", assignment, callback, errorCallback);
    }
    notifyResourceUnassigning(args: ResourceUnassigningArguments): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyResourceUnassigning", args);
    }
    notifyResourceUnassigned(assignmentID: any, errorCallback: () => void, assignment: any): void {
        if(!this.isLocked)
            this.onModelChanged.raise("NotifyResourceUnassigned", assignmentID, errorCallback, assignment);
    }
    notifyParentDataRecalculated(data: any): void {
        this.onModelChanged.raise("NotifyParentDataRecalculated", data);
    }

    fireResourceUnassigning(assignment: ResourceAssignment): boolean {
        const args = new ResourceUnassigningArguments(assignment);
        this.notifyResourceUnassigning(args);
        return !args.cancel;
    }

    raiseTaskTitleUpdating(task: Task, value: string, callback:(value: string) => void): boolean {
        return this.raiseTaskUpdating(task, "title", value, callback);
    }
    raiseTaskDescriptionUpdating(task: Task, value: string, callback:(value: string) => void): boolean {
        return this.raiseTaskUpdating(task, "description", value, callback);
    }
    raiseTaskProgressUpdating(task: Task, value: number, callback:(value: number) => void): boolean {
        return this.raiseTaskUpdating(task, "progress", value, callback);
    }
    raiseTaskColorUpdating(task: Task, value: string, callback:(value: string) => void): boolean {
        return this.raiseTaskUpdating(task, "color", value, callback);
    }
    raiseTaskStartUpdating(task: Task, value: Date, callback:(value: Date) => void): boolean {
        return this.raiseTaskUpdating(task, "start", value, callback);
    }
    raiseTaskEndUpdating(task: Task, value: Date, callback:(value: Date) => void): boolean {
        return this.raiseTaskUpdating(task, "end", value, callback);
    }
    raiseTaskStartAndEndUpdating(task: Task, newStart: Date, newEnd: Date, callback:(newStart, newEnd: Date) => void): boolean {
        const args = new TaskUpdatingArguments(task, ["start", "end"], [newStart, newEnd]);
        this.notifyTaskUpdating(args);
        if(!args.cancel) {
            callback(args["start"], args["end"]);
            return true;
        }
        return false;
    }
    raiseTaskUpdating(task: Task, fieldName: string, newValue: any, callback:(value: any) => void): boolean {
        const oldValue = task[fieldName];
        if(oldValue !== newValue) {
            const args = new TaskUpdatingArguments(task, [fieldName], [newValue]);
            this.notifyTaskUpdating(args);
            if(!args.cancel && oldValue !== args[fieldName]) {
                callback(args[fieldName]);
                return true;
            }
        }
        return false;
    }
    raiseTaskMultipleUpdating(task: Task, newValues: any, callback:(newValues: any) => void): boolean {
        const fields = ["title", "progress", "start", "end", "color"];
        const values = fields.map(f => newValues[f]);
        const args = new TaskUpdatingArguments(task, fields, values);
        this.notifyTaskUpdating(args);
        if(!args.cancel) {
            callback(args.newValues);
            return true;
        }
        return false;
    }
    raiseTaskMoving(task: Task, newStart: Date, newEnd: Date, callback:(newStart, newEnd: Date) => void): boolean {
        const args = new TaskUpdatingArguments(task, ["start", "end"], [newStart, newEnd]);
        this.notifyTaskMoving(args);
        if(!args.cancel) {
            callback(args["start"], args["end"]);
            return true;
        }
        return false;
    }
    raiseTaskTaskEditDialogShowing(params: TaskEditParameters, callback:(args: TaskEditDialogShowingArguments) => void): boolean {
        const args = new TaskEditDialogShowingArguments(params);
        this.notifyTaskEditDialogShowing(args);
        if(!args.cancel) {
            callback(args);
            return true;
        }
        return false;
    }

    raiseResourceManagerDialogShowing(params: ResourcesDialogParameters, callback:(args: ResourceManagerDialogShowingArguments) => void): boolean {
        const args = new ResourceManagerDialogShowingArguments(params);
        this.notifyResourceManagerDialogShowing(args);
        if(!args.cancel) {
            callback(args);
            return true;
        }
        return false;
    }

    public lock(): void { this.isLocked = true; }
    public unlock(): void { this.isLocked = false; }
}
