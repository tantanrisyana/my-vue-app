import { ModelManipulator } from "../../../Manipulators/ModelManipulator";
import { Task } from "../../../Entities/Task";
import { CompositionHistoryItem } from "../CompositionHistoryItem";
import { RemoveDependencyHistoryItem } from "../Dependency/RemoveDependencyHistoryItem";
import { HistoryItem } from "../HistoryItem";

export class RemoveTaskHistoryItem extends CompositionHistoryItem {
    taskIds: string[] = [];
    tasks: Task[] = [];
    private pendingCallbacks: number = 0;

    constructor(modelManipulator: ModelManipulator) {
        super();
        this.modelManipulator = modelManipulator;
    }
    public redo(): void {
        super.redo();
        this.taskIds.forEach(id => {
            this.tasks.push(this.modelManipulator.task.remove(id));
        });
    }
    public undo(): void {
        const viewModel = this.modelManipulator.task.viewModel;
        viewModel.lockChangesProcessing = this.tasks.length > 0;
        if(this.tasks.length) {
            const task = this.tasks.shift();
            this.pendingCallbacks++;
            this.modelManipulator.task.create(task, task.internalId, () => {
                this.modelManipulator.task.properties.progress.setValue(task.internalId, task.progress);
                if(task.color)
                    this.modelManipulator.task.properties.color.setValue(task.internalId, task.color);
                this.tasks.length ? this.undo() : super.undo();
                this.pendingCallbacks--;
                viewModel.lockChangesProcessing = this.pendingCallbacks > 0;
            });
        }
    }
    public undoItemsQuery(): void {
        while(this.tasks.length) {
            const task = this.tasks.shift();
            this.modelManipulator.task.create(task, task.internalId, () => { });
            this.modelManipulator.task.properties.progress.setValue(task.internalId, task.progress);
            if(task.color)
                this.modelManipulator.task.properties.color.setValue(task.internalId, task.color);
        }
        this.modelManipulator.task.viewModel.lockChangesProcessing = false;
        this.pendingCallbacks = 0;
        super.undo();
    }
    public addTask(taskId: string): void {
        this.taskIds.push(taskId);
    }
    public add(historyItem: HistoryItem): void {
        if(historyItem instanceof RemoveDependencyHistoryItem) {
            const item = <RemoveDependencyHistoryItem>historyItem;
            if(!this.historyItems.filter(i => i instanceof RemoveDependencyHistoryItem && i.dependencyId == item.dependencyId).length)
                this.historyItems.push(item);
        }
        else
            super.add(historyItem);
    }
}
