import { ModelChangesDispatcher } from "../../Dispatchers/ModelChangesDispatcher";
import { Task } from "../../Entities/Task";
import { ViewVisualModel } from "../../VisualModel/VisualModel";
import { BaseManipulator } from "../BaseManipulator";
import { TaskPropertiesManipulator } from "./Properties/TaskPropertiesManipulator";

export class TaskManipulator extends BaseManipulator {
    properties: TaskPropertiesManipulator;

    constructor(viewModel: ViewVisualModel, dispatcher: ModelChangesDispatcher) {
        super(viewModel, dispatcher);
        this.properties = new TaskPropertiesManipulator(viewModel, dispatcher);
    }

    create(data: Record<string, any>, id?: string, callback?: () => void): Task {
        const task = this.viewModel.tasks.createItem();
        task.start = data.start;
        task.end = data.end;
        task.title = data.title;
        task.progress = data.progress;
        if(data.color)
            task.color = data.color;
        const parentItem = this.viewModel.tasks.getItemById(data.parentId);
        if(parentItem)
            parentItem.expanded = true;
        task.parentId = data.parentId;
        if(id)
            task.internalId = id;
        task.id = task.internalId;
        this.viewModel.tasks.add(task);
        this.viewModel.updateModel();
        this.dispatcher.notifyTaskCreated(this.getObjectForDataSource(task), id => {
            task.id = id;
            if(callback)
                callback();
            if(this.viewModel.requireFirstLoadParentAutoCalc) {
                const data = this.viewModel.getCurrentTaskData().map(t => {
                    if(t.parentId === "")
                        t.parentId = null;
                    return t;
                });
                this.dispatcher.notifyParentDataRecalculated(data);
            }
        }, this.getErrorCallback());
        this.viewModel.owner.resetAndUpdate();
        return task;
    }
    remove(taskId: string): Task {
        const task = this.viewModel.tasks.getItemById(taskId);
        if(!task)
            throw new Error("Invalid task id");
        const dependencies = this.viewModel.dependencies.items.filter(d => d.predecessorId == taskId || d.successorId == taskId);
        if(dependencies.length)
            throw new Error("Can't delete task with dependency");
        const assignments = this.viewModel.assignments.items.filter(a => a.taskId == taskId);
        if(assignments.length)
            throw new Error("Can't delete task with assigned resource");
        this.viewModel.tasks.remove(task);
        this.dispatcher.notifyTaskRemoved(task.id, this.getErrorCallback(), this.viewModel.getTaskObjectForDataSource(task));
        this.viewModel.updateModel();
        this.viewModel.owner.resetAndUpdate();
        return task;
    }
    private getObjectForDataSource(task: Task) {
        return this.viewModel.getTaskObjectForDataSource(task);
    }
}
